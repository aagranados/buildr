---
layout: default
title: Languages
---


h2(#java). Java


h3. Compiling Java

The Java compiler looks for source files in the project's @src/main/java@ directory, and defaults to compiling them into the @target/classes@ directory. It looks for test cases in the project's @src/test/java@ and defaults to compile them into the @target/test/classes@ directory.

If you point the @compile@ task at any other source directory, it will use the Java compiler if any of these directories contains files with the extension @.java@.

When using the Java compiler, if you don't specify the packaging type, it defaults to JAR.  If you don't specify the test framework, it defaults to JUnit.

The Java compiler supports the following options:

|_. Option        |_. Usage |
| @:debug@        | Generates bytecode with debugging information.  You can also override this by setting the environment variable @debug@ to @off@. |
| @:deprecation@  | If true, shows deprecation messages.  False by default. |
| @:lint@         | Defaults to false.  Set this option to true to use all lint options, or specify a specific lint option (e.g. @:lint=>'cast'@). |
| @:other@        | Array of options passed to the compiler (e.g. @:other=>'-implicit:none'@). |
| @:source@       | Source code compatibility (e.g. '1.5'). |
| @:target@       | Bytecode compatibility (e.g. '1.4'). |
| @:warnings@     | Issue warnings when compiling.  True when running in verbose mode. |

h3. ECJ

You can use the  "ECJ compiler":http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_batch_compiler.htm instead of javac. ECJ abides to the same options as javac.
For example, to configure the project to use ECJ:
{% highlight ruby %}
compile.using :ecj
{% endhighlight %}

To use a custom version of ECJ, add an entry to your "settings":/settings_profiles.html.
For example, to set the version of ECJ to 3.5.1, add an entry to your project's @buildr.yml@:

{% highlight yaml %}
ecj: 3.5.1
{% endhighlight %}

h3.  Testing with Java

h4. JUnit

The default test framework for Java projects is "JUnit 4":http://www.junit.org.

When you use JUnit, the dependencies includes JUnit and "JMock":http://www.jmock.org, and Buildr picks up all test classes from the project by looking for classes that either subclass  @junit.framework.TestCase@, include methods annotated with @org.junit.Test@, or test suites annotated with @org.org.junit.runner.RunWith@.

The JUnit test framework supports the following options:

|_. Option        |_. Value |
| @:fork@         | VM forking, defaults to true. |
| @:clonevm@      | If true clone the VM each time it is forked. |
| @:properties@   | Hash of system properties available to the test case. |
| @:environment@  | Hash of environment variables available to the test case. |
| @:java_args@    | Arguments passed as is to the JVM. |

For example, to pass properties to the test case:

{% highlight ruby %}
test.using :properties=>{ :currency=>'USD' }
{% endhighlight %}

There are benefits to running test cases in separate VMs.  The default forking mode is @:once@, and you can change it by setting the @:fork@ option.

|_. :fork=> |_. Behavior |
| @:once@   | Create one VM to run all test classes in the project, separate VMs for each project. |
| @:each@   | Create one VM for each test case class.  Slow but provides the best isolation between test classes. |
| @false@   | Without forking, Buildr runs all test cases in a single VM.  This option runs fastest, but at the risk of running out of memory and causing test cases to interfere with each other. |

You can see your tests running in the console, and if any tests fail, Buildr will show a list of the failed test classes.  In addition, JUnit produces text and XML report files in the project's @reports/junit@ directory.  You can use that to get around too-much-stuff-in-my-console, or when using an automated test system.

In addition, you can get a consolidated XML or HTML report by running the @junit:report@ task.  For example:

{% highlight sh %}
$ buildr test junit:report test=all
$ firefox report/junit/html/index.html
{% endhighlight %}

The @junit:report@ task generates a report from all tests run so far.  If you run tests in a couple of projects, it will generate a report only for these two projects.  The example above runs tests in all the projects before generating the reports.

You can use the @build.yaml@ settings file to specify a particular version of JUnit or JMock.  For example, to force your build to use JUnit version 4.4 and JMock 2.0:

{% highlight yaml %}
junit: 4.4
jmock: 2.0
{% endhighlight %}


h4. TestNG

You can use "TestNG":http://testng.org instead of JUnit.  To select TestNG as the test framework, add this to your project:

{% highlight ruby %}
test.using :testng
{% endhighlight %}

Like all other options you can set with @test.using@, it affects the projects and all its sub-projects, so you only need to do this once at the top-most project to use TestNG throughout.  You can also mix TestNG and JUnit by setting different projects to use different frameworks, but you can't mix both frameworks in the same project.  (And yes, @test.using :junit@ will switch a project back to using JUnit)

TestNG works much like JUnit, it gets included in the dependency list along with JMock, Buildr picks test classes that contain methods annotated with  @org.testng.annotations.Test@, and generates test reports in the @reports/testng@ directory.  At the moment we don't have consolidated HTML reports for TestNG.

The TestNG test framework supports the following options:

|_. Option        |_. Value |
| @:properties@   | Hash of system properties available to the test case. |
| @:java_args@    | Arguments passed as is to the JVM. |

You can use the @build.yaml@ settings file to specify a particular version of TestNG, for example, to force your build to use TestNG 5.7:

{% highlight yaml %}
testng: 5.7
{% endhighlight %}


h4. JBehave

"JBehave":http://jbehave.org/ is a pure Java BDD framework, stories and behaviour specifications are written in the Java language.

To use JBehave in your project you can select it with @test.using :jbehave@.

This framework will search for the following patterns under your project:

{% highlight text %}
src/spec/java/**/*Behaviour.java
{% endhighlight %}

Supports the following options:

|_. Option        |_. Value |
| @:properties@   | Hash of system properties available to the test case. |
| @:java_args@    | Arguments passed as is to the JVM. |

You can use the @build.yaml@ settings file to specify a particular version of JBehave, for example, to force your build to use JBehave 1.0.1:

{% highlight yaml %}
jbehave: 1.0.1
{% endhighlight %}


h3. Documentation

Buildr offers support for using JavaDoc to generate documentation from any Java sources in a project.  This is done using the @doc@ task:

{% highlight sh %}
$ buildr doc
{% endhighlight %}

This will use the same @.java@ sources used by the @compile@ task to produce JavaDoc results in the @target/doc/@ directory.  By default, these sources are chosen only from the current project.  However, it is possible to override this and generate documentation from the sources in a sub-project (potentially more than one):

{% highlight ruby %}
define 'foo' do
  # ...

  doc.from projects('foo:bar', 'foo')

  define 'bar' do
    # ...
  end
end
{% endhighlight %}

With this configuration, the @doc@ task will use sources from both @foo:bar@ and
@foo@.

The @doc@ task supports any option that the @javadoc@ command does (e.g. @-windowtitle@).  To pass an option to the JavaDoc generator, simply specify it using the @doc@ method:

{% highlight ruby %}
define 'foo' do
  # ...

  doc :windowtitle => 'Abandon All Hope, Ye Who Enter Here', :private => true
end
{% endhighlight %}

h2(#groovy). Groovy

h3. Compiling Groovy

Before using the Groovy compiler, you must first require it on your buildfile:

{% highlight ruby %}
require 'buildr/java/groovyc'
{% endhighlight %}

Once loaded, the groovyc compiler will be automatically selected if any .groovy source files are found under @src/main/groovy@ directory, compiling them by default into the @target/classes@ directory.

If the project has java sources in @src/main/java@ they will get compiled using the groovyc joint compiler.

Sources found in @src/test/groovy@ are compiled into the @target/test/classes@.

If you don't specify the packaging type, it defaults to JAR.

The Groovy compiler supports the following options:

|_. Option        |_. Usage |
| @encoding@          | Encoding of source files. |
| @verbose@           | Asks the compiler for verbose output, true when running in verbose mode. |
| @fork@              | Whether to execute groovyc using a spawned instance of the JVM.  Defaults to no. |
| @memoryInitialSize@ | The initial size of the memory for the underlying VM, if using fork mode, ignored otherwise.  Defaults to the standard VM memory setting. (Examples: @83886080@, @81920k@, or @80m@) |
| @memoryMaximumSize@ | The maximum size of the memory for the underlying VM, if using fork mode, ignored otherwise.  Defaults to the standard VM memory setting. (Examples: @83886080@, @81920k@, or @80m@) |
| @listfiles@         | Indicates whether the source files to be compiled will be listed.  Defaults to no. |
| @stacktrace@        | If true each compile error message will contain a stacktrace. |
| @warnings@          | Issue warnings when compiling.  True when running in verbose mode. |
| @debug@             | Generates bytecode with debugging information.  Set from the debug environment variable/global option. |
| @deprecation@       | If true, shows deprecation messages.  False by default. |
| @optimise@          | Generates faster bytecode by applying optimisations to the program. |
| @source@            | Source code compatibility. |
| @target@            | Bytecode compatibility. |
| @javac@             | Hash of options passed to the ant javac task. |

h3. Testing with Groovy

h4. EasyB

"EasyB":http://www.easyb.org/ is a BDD framework using "Groovy":http://groovy.codehaus.org/.

Specifications are written in the Groovy language, of course you get seamless Java integration as with all things groovy.

To use this framework in your project you can select it with @test.using :easyb@.

This framework will search for the following patterns under your project:

{% highlight text %}
src/spec/groovy/**/*Behavior.groovy
src/spec/groovy/**/*Story.groovy
{% endhighlight %}

Supports the following options:

|_. Option        |_. Value |
| @:properties@   | Hash of system properties available to the test case. |
| @:java_args@    | Arguments passed as is to the JVM. |
| @:format@       | Report format, either @:txt@ or @:xml@ |


h3. Documentation

Buildr offers support for using GroovyDoc to generate documentation from any Groovy sources in a project.  This is done using the @doc@ task:

{% highlight sh %}
$ buildr doc
{% endhighlight %}

This will use the same @.groovy@ sources used by the @compile@ task to produce GroovyDoc results in the @target/doc/@ directory.  By default, these sources are chosen only from the current project.  However, it is possible to override this and generate documentation from the sources in a sub-project (potentially more than one):

{% highlight ruby %}
define 'foo' do
  # ...

  doc.from projects('foo:bar', 'foo')

  define 'bar' do
    # ...
  end
end
{% endhighlight %}

With this configuration, the @doc@ task will use sources from both @foo:bar@ and
@foo@.

The @doc@ task supports any option that the @groovydoc@ command does (e.g. @-windowtitle@).  To pass an option to the GroovyDoc generator, simply specify it using the @doc@ method:

{% highlight ruby %}
define 'foo' do
  # ...

  doc :windowtitle => 'Abandon All Hope, Ye Who Enter Here', :private => true
end
{% endhighlight %}

The @doc@ task is *not* joint-compilation aware.  Thus, it will only generate GroovyDoc for mixed-source projects, it will not attempt to generate both JavaDoc and GroovyDoc.


h2(#ruby).  Ruby

h3.  Testing with Ruby

Buildr provides integration with some ruby testing frameworks, allowing you to test your Java code with state of the art tools.

Testing code is written in "Ruby":http://www.ruby-lang.org/en/ language, and is run by using "JRuby":http://jruby.codehaus.org/. That means you have access to all your Java classes and any Java or Ruby tool out there.

Because of the use of JRuby, you will notice that running ruby tests is faster when running Buildr on JRuby, as in this case there's no need to run another JVM.

p(tip). When not running on JRuby, Buildr will use the @JRUBY_HOME@ environment variable to find the JRuby installation directory.  If no @JRUBY_HOME@ is set or it points to an empty directory, Buildr will prompt you to either install JRuby manually or let it  extract it for you.

You can use the @build.yaml@ settings file to specify a particular version of JRuby (defaults to @1.4.0@ as of Buildr 1.3.5).  For example:

{% highlight yaml %}
jruby: 1.3.1
{% endhighlight %}

h4.  RSpec

"RSpec":http://rspec.info/ is the de-facto BDD framework for ruby. It's the framework used to test Buildr itself.

To use this framework in your project you can select it with @test.using :rspec@.

This framework will search for the following patterns under your project:

{% highlight text %}
src/spec/ruby/**/*_spec.rb
{% endhighlight %}

Supports the following options:

|_. Option        |_. Value |
| @:gems@         | Hash of gems needed before running the tests. Keys are gem names, values are the required gem version. An example use of this option would be to require the ci_reporter gem to generate xml reports |
| @:requires@     | Array of ruby files to require before running the specs |
| @:format@       | Array of valid RSpec @--format@ option values. Defaults to html report on the @reports@ directory and text progress |
| @:output@       | File path to output dump. @false@ to supress output |
| @:fork@         | Run the tests on a new java vm. (enabled unless running on JRuby) |
| @:properties@   | Hash of system properties available to the test case. |
| @:java_args@    | Arguments passed as is to the JVM. (only when fork is enabled) |
